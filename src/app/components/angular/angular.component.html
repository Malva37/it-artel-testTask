<ol>
  <li>Яка різниця між *ngIf і [hidden]?</li>
  <b>
    *ngIf - це структурна директива, яка дозволяє додавати чи видаляти елемент з дом-дерева. Коли умова true, елемент з'являється, інакше - він видаляється зі сторінки. Якщо використовувати *ngIf, то дерево DOM буде змінюватися динамічно при зміні значень.

    [hidden] - це атрибут, який приховує елемент, якщо його значення true. Це не змінює дом-дерево, а просто застосовує до нього стилі, які роблять його невидимим для користувача. Якщо використовувати [hidden], то елемент залишається в дереві DOM, але він не відображається.

    Якщо необхідно динамічно змінювати дерево DOM в залежності від умови, краще використати *ngIf. А використання [hidden] корисно, якщо потрібно просто приховати елемент без зміни дерева DOM.
  </b>
  
  <li>Що таке Observable?</li>
  <b>
    Observable - це один з основних класів в бібліотеці RxJS, який дозволяє працювати з асинхронними потоками даних(з запитами до сервера).

    Основна відмінність між Observable та іншими асинхронними підходами (такими як Promise) полягає в тому, що Observable повідомляє про декілька значень у межах одного потоку, тоді як Promise повідомляє тільки про одне значення.
  </b>

  <li>
      <p>Розглянемо наступний компонент:</p>
      <pre style="border: 1px solid grey; padding: 10px">
        <code>
  import &#123; Component, Input } from '@angular/core';

  @Component(&#123;
  selector: 'welcome',
  template: `&lt;h1>Welcome to &#123; &#123; name } }!&lt;/h1>`,
  styles: [`h1 &#123; font-family: Lato; }`]
  })
  export class WelcomeComponent &#123;
  @Input() name: string;
  }
      </code>
    </pre>
      <p>Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).</p>
      <p>(Виберіть усі прийнятні відповіді.)</p>
      <ol>
          <li>&lt;welcome name="TestDome">&lt;/welcome> відображатиме: "Welcome to TestDome!".</li>
          <li>&lt;welcome>&lt;/welcome> нічого не відображатиме.</li>
          <li>@NgModule(&#123; declarations: [ WelcomeComponent ] }) export class WelcomeModule&#123;} повідомляє, що компонент привітання належить модулю привітання.</li>
          <li>&lt;hello name="&#123; &#123; name } }">&lt;/hello> відображатиме: "Welcome to name!".</li>
      </ol>
  </li>
  <b>Правильними твердженями будуть перші три варіанти. Останнє твердження не вірне, адже: компонент називається WelcomeComponent, а не HelloComponent, і не має параметру name</b>

  <li>
      <p>Розглянемо наступний компонент, який можна використовувати для моделювання тварини та її шуму.</p>
      <pre style="border: 1px solid grey; padding: 10px">
        <code>
  import &#123; Component, Input, Output} from '@angular/core';

  @Component(&#123;
  selector: 'animal-noise',
  template: `
      &lt;span>&#123; &#123; animal } }&lt;/span>
      &lt;button (click)="makeNoise()">Make noise&lt;/button>
  `
  })
  export class AnimalNoise
      @Input('animal') animal: string;
      @Input('noise') noise: string;

      makeNoise()
          alert(`$&#123;this.noise}`);
      </code>
    </pre>
      <p>Виберіть правильні твердження про компонент AnimalNoise.</p>
      <p>(Виберіть усі прийнятні відповіді.)</p>
      <ol>
          <li>Component, Input і Output всі необхідні імпорти цього компонента.</li>
          <li>При включенні компонента AnimalNoise у шаблон мають бути вказані вхідні дані як тварин, так і шуму.</li>
          <li>Параметр 'animal' у оголошенні @Input ('animal') не змінює інтерфейс компонента.</li>
          <li>При включенні до шаблону компонентів компонент AnimalNoise створює діапазон, що містить інтерполіроване ім'я тварин і кнопку, прив'язану до makeNoise().</li>
          <li>Компонент AnimalNoise може бути включений в інший шаблон за допомогою тега &lt;AnimalNoise>.</li>
      </ol>
  </li>
  <b>Перше твердження не вірне, Output зайвий імпорт. Друге та четверте твердження вірні. Трете також є вірним, адже @Input('animal') лише задає псевдонім для вхідного параметру. Пяте не вірне, включення можливе за використання наступного тегу: &lt;angular-noise&gt;
  </b>

  <li>
      <p>Розглянемо наступний модуль програми:</p>
      <pre style="border: 1px solid grey; padding: 10px">
        <code>
  import &#123; NgModule }             from '@angular/core';
  import &#123; RouterModule, Routes } from '@angular/router';
  import &#123; HomeComponent }        from './home.component';
  import &#123; ItemDetailComponent }  from './item-detail.component';
  const routes: Routes = [
  &#123; path: '', redirectTo: '/home', pathMatch: 'full' },
  &#123; path: 'home',  component: HomeComponent },
  &#123; path: 'detail/:id', component: ItemDetailComponent, outlet: 'route1' }
  ];
  @NgModule(&#123;
      imports: [ RouterModule.forRoot(routes) ],
      exports: [ RouterModule ]
  })
  export class AppRoutingModule &#123;}
      </code>
    </pre>
      <p>Які з таких тверджень щодо поведінки маршрутизаторів є правильними?</p>
      <p>(Виберіть усі прийнятні відповіді.)</p>
      <ol>
          <li>Доступ до домашнього компонента можливий лише через перенаправлення кореневої URL-адреси.</li>
          <li>Параметр id не є обов'язковим, коли виконується виклик / detail / URL.</li>
          <li>Необов'язкові параметри можуть бути передані до будь-якого компонента через параметри запиту ActivatedRoute.</li>
          <li>/detail/100 використовуватиме &lt;router-outlet name='route1'> для визначення позиції виду.</li>
          <li>Route, який перенаправляє на HomeComponent, активується на тих самих маршрутах, якщо властивість pathMatch: 'full' була видалена.</li>
      </ol>
  </li>
  <b>Твердження 1, 3, 4 є вірними</b>

  <li>
    <p>
      Розглянемо наступні два базові класи, Positionable і Rotatable, і похідний клас MovingObject:
    </p>
    <pre style="border: 1px solid grey; padding: 10px">
      <code>
  class Positionable &#123;
      locationX: number;
      locationY: number;
  }

  class Rotatable &#123;
      orientation: number;
      rotate(orientation: number) &#123;
          this.orientation += orientation;
      }
      align(rotatable: Rotatable)&#123;
          this.orientation = rotatable.orientation;
      }
  }

  class MovingObject implements Positionable, Rotatable &#123;
      locationX: number = 0;
      locationY: number = 0;
      orientation: number = 0;
      rotate: (orientation: number) => void;
  }

  applyMixins(MovingObject, [Positionable, Rotatable]);
  function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;
      baseCtors.forEach(baseCtor => &#123;
          Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => &#123;
              derivedCtor.prototype[name] = baseCtor.prototype[name];
          });
      });
  }

  let mover = new MovingObject();
  mover.rotate(30);
      </code>
    </pre>
      <p>Виберіть правильні твердження.</p>
      <p>(Виберіть усі прийнятні відповіді.)</p>
      <ol>
          <li>Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject.</li>
          <li>Компілятор TypeScript підкреслить, що властивість "align" відсутня для типу MovingObject.</li>
          <li>Оскільки MovingObject реалізує Rotatable, виклик mover.rotate(30) нічого не зробить.</li>
          <li>Клас Positionable можна змінити на інтерфейс без помилок компілятора.</li>
          <li>Властивості MovingObject необхідні як резервні для задоволення компілятора TypeScript.</li>
      </ol>
  </li>
  <b>Перше та друге твердження вірні</b>

  <li>
      <p>Розглянемо такі компоненти:</p>
      <pre style="border: 1px solid grey; padding: 10px">
        <code>
  export class Address &#123;
      street: String;
      city: String;
      zipCode: String;
  }

  @Component(&#123;
      selector: 'app-address',
      templateUrl: './address.component.html',
      styleUrls: ['./address.component.css']
  })
  export class AddressComponent implements OnInit

      @Input() address: Address;
      constructor() &#123; }

      ngOnInit() &#123;

      }
  }

  @Component(&#123;
      selector: 'app-address-list',
      templateUrl: './address-list.component.html',
      styleUrls: ['./address-list.component.css']
  })
  export class AddressListComponent implements OnInit &#123;

      @Input() addresses: Address[];
      constructor() &#123; }

      ngOnInit() &#123;

      }
  }
      </code>
    </pre>
      <p>Нижче наведено файл address-list.component.html. Заповніть пробіли, щоб шаблон відображав один елемент li на адресу, і коректно пов'язував кожну адресу з полем AddressComponent.</p>
      <pre style="border: 1px solid grey; padding: 10px">
        <code>
  &lt;ul>
      &lt;li <input type="text"/>="let address of <input type="text"/>">
          &lt;app-address <input type="text"/>="address">&lt;/app-address>
      &lt;/li>
  &lt;/ul>
      </code>
    </pre>
  </li>
  <b>Відповідь:
    <pre>
      <code>
  &lt;ul>
      &lt;li *ngFor="let address of addresses">
          &lt;app-address [address]="address">&lt;/app-address>
      &lt;/li>
  &lt;/ul>
    </code>
  </pre>
  </b>
</ol>
